<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Simple - Jeu de Poursuite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            height: 100vh;
            cursor: none;
        }

        #game {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .player {
            width: 40px;
            height: 40px;
            background: #00d4ff;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff;
            z-index: 10;
        }

        .player::before {
            content: 'üòä';
            font-size: 24px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .monster {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            transition: background 0.3s;
        }

        .monster1 {
            background: #ff4757;
            box-shadow: 0 0 15px #ff4757, 0 0 30px #ff4757;
        }

        .monster1::before {
            content: 'üëπ';
            font-size: 22px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .monster2 {
            background: #a55eea;
            box-shadow: 0 0 15px #a55eea, 0 0 30px #a55eea;
        }

        .monster2::before {
            content: 'üëª';
            font-size: 22px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .trap {
            width: 45px;
            height: 45px;
            position: absolute;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: radial-gradient(circle, #2ecc71 0%, #27ae60 50%, #1e8449 100%);
            box-shadow: 0 0 15px #2ecc71, 0 0 30px rgba(46, 204, 113, 0.5);
            z-index: 5;
            animation: trapPulse 1.5s ease-in-out infinite;
        }

        .trap::before {
            content: 'ü™§';
            font-size: 24px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .trap.triggered {
            animation: trapExplode 0.5s ease-out forwards;
        }

        @keyframes trapPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        @keyframes trapExplode {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }

        .monster.dying {
            animation: monsterDie 0.5s ease-out forwards;
        }

        @keyframes monsterDie {
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0) rotate(720deg); opacity: 0; }
        }

        #score {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: 20px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            line-height: 1.6;
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            display: none;
            z-index: 200;
            border: 3px solid #ff4757;
        }

        #gameOver h1 {
            color: #ff4757;
            margin-bottom: 20px;
        }

        #gameOver p {
            margin: 10px 0;
        }

        #gameOver button {
            background: #00d4ff;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s, background 0.2s;
        }

        #gameOver button:hover {
            transform: scale(1.1);
            background: #00b8e6;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.6);
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            z-index: 100;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game">
        <div class="player" id="player"></div>
        <div class="monster monster1" id="monster1"></div>
        <div class="monster monster2" id="monster2"></div>
    </div>

    <div id="score">
        ‚è±Ô∏è Survie: <span id="time">0</span>s<br>
        üíÄ Monstres tu√©s: <span id="kills">0</span><br>
        ü™§ Pi√®ges: <span id="trapCount">3</span>
    </div>

    <div id="instructions">
        üéÆ Souris = d√©placer | Clic = poser un pi√®ge<br>
        √âvitez les monstres et pi√©gez-les!
    </div>

    <div id="gameOver">
        <h1>üíÄ GAME OVER!</h1>
        <p>Vous avez surv√©cu <span id="finalTime">0</span> secondes!</p>
        <p>Monstres √©limin√©s: <span id="finalKills">0</span></p>
        <button onclick="restartGame()">üîÑ Rejouer</button>
    </div>

    <script>
        const game = document.getElementById('game');
        const player = document.getElementById('player');
        const monster1 = document.getElementById('monster1');
        const monster2 = document.getElementById('monster2');
        const timeDisplay = document.getElementById('time');
        const killsDisplay = document.getElementById('kills');
        const trapCountDisplay = document.getElementById('trapCount');
        const finalTimeDisplay = document.getElementById('finalTime');
        const finalKillsDisplay = document.getElementById('finalKills');
        const gameOverScreen = document.getElementById('gameOver');

        let playerX = window.innerWidth / 2;
        let playerY = window.innerHeight / 2;

        let monster1X = 100;
        let monster1Y = 100;
        let monster1Active = true;

        let monster2X = window.innerWidth - 100;
        let monster2Y = window.innerHeight - 100;
        let monster2Active = true;

        let gameRunning = true;
        let startTime = Date.now();
        let survivalTime = 0;
        let kills = 0;
        let trapsAvailable = 3;
        let traps = [];

        const monster1Speed = 2.5;
        const monster2Speed = 2;
        const trapRadius = 25;
        const monsterRadius = 17;

        // Suivi de la souris
        document.addEventListener('mousemove', (e) => {
            if (gameRunning) {
                playerX = e.clientX;
                playerY = e.clientY;
            }
        });

        // Poser un pi√®ge au clic
        document.addEventListener('click', (e) => {
            if (gameRunning && trapsAvailable > 0) {
                placeTrap(e.clientX, e.clientY);
            }
        });

        // Placer un pi√®ge
        function placeTrap(x, y) {
            trapsAvailable--;
            trapCountDisplay.textContent = trapsAvailable;

            const trap = document.createElement('div');
            trap.className = 'trap';
            trap.style.left = x + 'px';
            trap.style.top = y + 'px';
            game.appendChild(trap);

            traps.push({
                element: trap,
                x: x,
                y: y,
                active: true
            });

            // Reg√©n√©rer un pi√®ge apr√®s 5 secondes
            setTimeout(() => {
                if (gameRunning) {
                    trapsAvailable++;
                    trapCountDisplay.textContent = trapsAvailable;
                }
            }, 5000);
        }

        // Mise √† jour de la position du joueur
        function updatePlayer() {
            player.style.left = playerX + 'px';
            player.style.top = playerY + 'px';
        }

        // Respawn d'un monstre √† une position al√©atoire loin du joueur
        function respawnMonster(monsterNum) {
            let newX, newY;
            const minDist = 200;

            do {
                newX = Math.random() * (window.innerWidth - 100) + 50;
                newY = Math.random() * (window.innerHeight - 100) + 50;
            } while (Math.sqrt((newX - playerX) ** 2 + (newY - playerY) ** 2) < minDist);

            if (monsterNum === 1) {
                monster1X = newX;
                monster1Y = newY;
                monster1Active = true;
                monster1.classList.remove('dying');
                monster1.style.display = 'block';
            } else {
                monster2X = newX;
                monster2Y = newY;
                monster2Active = true;
                monster2.classList.remove('dying');
                monster2.style.display = 'block';
            }
        }

        // V√©rifier collision monstre-pi√®ge
        function checkTrapCollisions() {
            traps.forEach((trap, index) => {
                if (!trap.active) return;

                // Monstre 1
                if (monster1Active) {
                    const dist1 = Math.sqrt((monster1X - trap.x) ** 2 + (monster1Y - trap.y) ** 2);
                    if (dist1 < trapRadius + monsterRadius) {
                        killMonster(1, trap, index);
                        return;
                    }
                }

                // Monstre 2
                if (monster2Active) {
                    const dist2 = Math.sqrt((monster2X - trap.x) ** 2 + (monster2Y - trap.y) ** 2);
                    if (dist2 < trapRadius + monsterRadius) {
                        killMonster(2, trap, index);
                        return;
                    }
                }
            });
        }

        // Tuer un monstre
        function killMonster(monsterNum, trap, trapIndex) {
            kills++;
            killsDisplay.textContent = kills;

            // D√©sactiver le pi√®ge
            trap.active = false;
            trap.element.classList.add('triggered');
            setTimeout(() => {
                trap.element.remove();
            }, 500);

            // Animation de mort du monstre
            if (monsterNum === 1) {
                monster1Active = false;
                monster1.classList.add('dying');
                setTimeout(() => {
                    if (gameRunning) respawnMonster(1);
                }, 1500);
            } else {
                monster2Active = false;
                monster2.classList.add('dying');
                setTimeout(() => {
                    if (gameRunning) respawnMonster(2);
                }, 1500);
            }

            // Bonus: regagner un pi√®ge apr√®s avoir tu√© un monstre
            trapsAvailable++;
            trapCountDisplay.textContent = trapsAvailable;

            // Nettoyer le tableau des pi√®ges
            traps = traps.filter(t => t.active);
        }

        // D√©placement des monstres vers le joueur
        function updateMonsters() {
            // Monstre 1 - poursuit le joueur
            if (monster1Active) {
                let dx1 = playerX - monster1X;
                let dy1 = playerY - monster1Y;
                let dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                if (dist1 > 0) {
                    monster1X += (dx1 / dist1) * monster1Speed;
                    monster1Y += (dy1 / dist1) * monster1Speed;
                }

                monster1.style.left = monster1X + 'px';
                monster1.style.top = monster1Y + 'px';
            }

            // Monstre 2 - poursuit le joueur
            if (monster2Active) {
                let dx2 = playerX - monster2X;
                let dy2 = playerY - monster2Y;
                let dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                if (dist2 > 0) {
                    monster2X += (dx2 / dist2) * monster2Speed;
                    monster2Y += (dy2 / dist2) * monster2Speed;
                }

                monster2.style.left = monster2X + 'px';
                monster2.style.top = monster2Y + 'px';
            }

            // Les monstres s'√©vitent l√©g√®rement entre eux
            if (monster1Active && monster2Active) {
                let dxM = monster2X - monster1X;
                let dyM = monster2Y - monster1Y;
                let distM = Math.sqrt(dxM * dxM + dyM * dyM);

                if (distM < 60 && distM > 0) {
                    monster1X -= (dxM / distM) * 0.5;
                    monster1Y -= (dyM / distM) * 0.5;
                    monster2X += (dxM / distM) * 0.5;
                    monster2Y += (dyM / distM) * 0.5;
                }
            }
        }

        // V√©rification des collisions joueur-monstre
        function checkCollision() {
            const playerRadius = 20;
            const collisionDist = playerRadius + monsterRadius;

            // Collision avec monstre 1
            if (monster1Active) {
                let dx1 = playerX - monster1X;
                let dy1 = playerY - monster1Y;
                let dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                if (dist1 < collisionDist) {
                    gameOver();
                    return;
                }
            }

            // Collision avec monstre 2
            if (monster2Active) {
                let dx2 = playerX - monster2X;
                let dy2 = playerY - monster2Y;
                let dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                if (dist2 < collisionDist) {
                    gameOver();
                }
            }
        }

        // Mise √† jour du temps
        function updateTime() {
            if (gameRunning) {
                survivalTime = Math.floor((Date.now() - startTime) / 1000);
                timeDisplay.textContent = survivalTime;
            }
        }

        // Game Over
        function gameOver() {
            gameRunning = false;
            finalTimeDisplay.textContent = survivalTime;
            finalKillsDisplay.textContent = kills;
            gameOverScreen.style.display = 'block';
            document.body.style.cursor = 'default';
        }

        // Red√©marrer le jeu
        function restartGame() {
            // Nettoyer les pi√®ges
            traps.forEach(trap => trap.element.remove());
            traps = [];

            playerX = window.innerWidth / 2;
            playerY = window.innerHeight / 2;

            monster1X = 100;
            monster1Y = 100;
            monster1Active = true;
            monster1.classList.remove('dying');
            monster1.style.display = 'block';

            monster2X = window.innerWidth - 100;
            monster2Y = window.innerHeight - 100;
            monster2Active = true;
            monster2.classList.remove('dying');
            monster2.style.display = 'block';

            gameRunning = true;
            startTime = Date.now();
            survivalTime = 0;
            kills = 0;
            trapsAvailable = 3;

            killsDisplay.textContent = 0;
            trapCountDisplay.textContent = 3;

            gameOverScreen.style.display = 'none';
            document.body.style.cursor = 'none';
        }

        // Boucle de jeu principale
        function gameLoop() {
            if (gameRunning) {
                updatePlayer();
                updateMonsters();
                checkTrapCollisions();
                checkCollision();
                updateTime();
            }
            requestAnimationFrame(gameLoop);
        }

        // D√©marrer le jeu
        updatePlayer();
        monster1.style.left = monster1X + 'px';
        monster1.style.top = monster1Y + 'px';
        monster2.style.left = monster2X + 'px';
        monster2.style.top = monster2Y + 'px';

        gameLoop();
    </script>
</body>
</html>